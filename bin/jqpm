#!/usr/bin/env node
'use strict';

/**
 * jqpm -- jQuery Package Manager
 * http://github.com/Xion/jqpm
 */


var util = require('util')
  , buffer = require('buffer')
  , fs = require('fs')
  , path = require('path')
  , querystring = require('querystring')
  , http = require('http')
  , https = require('https')
  , url = require('url')
  ;
var async = require('async')
  , argparse = require('argparse')
  ;


var DATA_DIR = ".jqpm";


/* jqpm commands */

/**
 * Install given list of packages.
 * :param packages: List of package names to install
 */
function installPackages(packages) {
	async.forEach(packages, installPackage);
}

/**
 * Installs a single package.
 */
function installPackage(name) {
	var dataDir = getDataDirectory();

	var repo, plugin;
	var manifest;
	var date;

	async.waterfall([
		function(next) {
			github.searchRepos(name, next);
		},
		function(repos, next) {
			repo = repos[0];

			// look for something that looks like plugin's JS file
			github.listFiles(repo.owner, repo.name, next);
		},
		function(files, next) {
			for (var fname in files) {
				if (!files.hasOwnProperty(fname))
					continue;
				var match = fname.toLowerCase().match(/^jquery\.(.*)\.js$/)
				if (match) {
					plugin = {
						name: match[1],
						filename: fname,
						url: files[fname],
					};
					break;
				}
			}
			if (!plugin) {
				next(new Error(util.format(
					"repository %s/%s does not have anything " +
					"that looks like a jQuery plugin",
					repo.owner, repo.name)));
			} else {
				// create manifest
				manifest = {
					name: plugin.name,
					title: repo.name,
					author: {
						name: repo.owner,
						url: "http://github.com/" + repo.owner,
					},
					homepage: util.format("http://github.com/%s/%s",
										  repo.owner, repo.name),
				};

				// use date of last commit that changed the plugin file
				github.getCommits(repo.owner, repo.name, {path: plugin.filename}, next);
			}
		},
		function(commits, next) {
			date = commits[0].commit.committer.date;
			httpGet(plugin.url, next);
		},
		function(respBody, next) {
			var resp = JSON.parse(respBody);

			var pluginFile = base64Decode(resp.content);
			var pluginFileName = util.format("jquery.%s.js", name.toLowerCase());
			fs.writeFileSync(path.join(process.cwd(), pluginFileName), pluginFile);

			// save package information in data directory
			var infoFilePath = path.join(dataDir, name + ".json");
			fs.writeFileSync(infoFilePath, JSON.stringify({
				manifest: manifest,
				date: date,
			}));

			next();
		},
	], function(err) {
		if (err) {
			log('error', "failed to install %s: %s", name, err);
		} else {
			log('info', "%s installed successfully", name);
		}
	});
}

/**
 * Uninstalls given list of packages.
 * :param packages: List of packages to uninstall
 */
function uninstallPackages(packages) {
	async.forEach(packages, uninstallPackage);
}

/**
 * Uninstalls a single package.
 */
function uninstallPackage(name) {
	var dataDir = getDataDirectory();

	var infoFilePath = path.join(dataDir, name + ".json");
	if (fs.existsSync(infoFilePath)) {
		var jsFileName = util.format("jquery.%s.js", name.toLowerCase());
		var jsFilePath = path.join(process.cwd(), jsFileName);
		if (fs.existsSync(jsFilePath)) {
			fs.unlinkSync(jsFilePath);
			fs.unlinkSync(infoFilePath);
			log('info', "%s uninstalled", name);
		} else {
			log('warn', "%s not found -- removing from installed plugins",
						jsFileName);
			fs.unlinkSync(infoFilePath);
		}

	} else {
		log('warn', "%s not installed -- skipping", name);
	}
}


/* GitHub API calls */

var github = (function() {
	var _ = {
		/**
		 * Search for repositories matching given query.
		 * :return: An array of objects with repository infos
		 */
		searchRepos: function(query, callback) {
			var url = util.format("%s/legacy/repos/search/%s",
								  GITHUB_URL, querystring.escape(query));
			httpGet(url, function(err, respBody) {
				if (err) {
					callback(err);
				} else {
					var resp = JSON.parse(respBody);
					callback(null, resp.repositories);
				}
			});
		},

		/**
		 * Lists all files in root directory of ``repo`` belonging
		 * to given ``user``.
		 * :return: Object mapping file and directory names to URLs
		 */
		listFiles: function(user, repo, ref, callback) {
			if (!callback) {
				callback = ref;
				ref = 'master';	// ``ref`` is optional
			}

			var url = util.format("%s/repos/%s/%s/git/trees/%s",
								  GITHUB_URL, user, repo, ref);
			httpGet(url, function(err, respBody) {
				if (err) {
					callback(err);
				} else {
					var resp = JSON.parse(respBody);
					var res = {};
					resp.tree.forEach(function(item) {
						var key = item.path;
						if (item.type === 'tree')
							key += '/';
						res[key] = item.url;
					});
					callback(null, res);
				}
			});
		},

		/**
		 * Gets list of commits from ``repo`` belonging to given ``user``.
		 * :param options: May contain:
		 *                 * ``fromRef`` to specify starting revision
		 *                 * ``path`` includes only commits touching the path
		 * :return: Array of objects with commit infos
		 */
		getCommits: function(user, repo, options, callback) {
			if (!callback) {
				callback = options;
				options = {}; // ``options`` are optional
			}

			var args = {
				sha: (options.fromRef ? options.fromRef : 'master')
			};
			if (options.path)
				args.path = options.path;
			var qsArgs = querystring.encode(args);

			var url = util.format("%s/repos/%s/%s/commits",
								  GITHUB_URL, user, repo);
			if (qsArgs)
				url += "?" + qsArgs;

			httpGet(url, function(err, respBody) {
				if (err) {
					callback(err);
				} else {
					var commits = JSON.parse(respBody);
					callback(null, commits);
				}
			});
		},
	};

	var GITHUB_URL = "https://api.github.com";

	return _;
})();


/* Various utility functions */

function log(what, msg) {
	var args = [].slice.call(arguments, 2);
	args.unshift("[jqpm] " + msg);
	return console[what].apply(null, args);
}

function getDataDirectory() {
	var dataDir = path.join(process.cwd(), DATA_DIR);

	var exists = fs.existsSync(dataDir);
	if (exists) {
		var isDir = fs.statSync(dataDir).isDirectory();
		if (!isDir) {
			throw new Error(util.format(
				"'%s' found to not be directory -- aborting.", DATA_DIR));
		}
	} else {
		fs.mkdirSync(dataDir);
	}

	return dataDir;
}

function httpGet(targetUrl, callback) {
	if (typeof targetUrl === 'string')
		targetUrl = url.parse(targetUrl);
	var protocol = targetUrl.protocol === 'https:' ? https : http;
	var req = protocol.get(targetUrl, function(resp) {
		if (resp.statusCode >= 200 && resp.statusCode < 300) {
			resp.setEncoding('utf8');

			var respBody = "";
			resp.on('data', function(chunk) {
				respBody += chunk;
			});
			resp.on('end', function() {
				callback(null, respBody);
			});
		} else {
			var err = new Error(util.format("HTTP error: %s", resp.statusCode));
			err.statusCode = resp.statusCode;
			callback(err);
		}
	});
	req.on('error', callback);
}

function base64Decode(data) {
	return buffer.Buffer(data, 'base64').toString();
}


/* main(), command line arguments handling etc. */

/**
 * Main function.
 * :param args: Command line arguments, as parsed by argparse
 */
function main(args) {
	try {
		switch(args.command) {
			case 'install':
				return installPackages(args.package);
			case 'uninstall':
				return uninstallPackages(args.package);
		}
	} catch (e) {
		log('error', e.message);
	}
}

/**
 * Creates the ArgumentParser object to parse command line args.
 */
function argumentParser() {
	var parser = new argparse.ArgumentParser({
		prog: "jqpm",
		description: "jQuery Package Manager",
		usage: "jqpm COMMAND [OPTIONS]",
	});
	var subparsers = parser.addSubparsers({dest: "command"});

	var installParser = subparsers.addParser('install', {addHelp: true});
	installParser.addArgument(['package'], {
		action: 'append',
		help: "Package(s) to install"
	});

	var uninstallParser = subparsers.addParser('uninstall', {addHelp: true});
	uninstallParser.addArgument(['package'], {
		action: 'append',
		help: "Package(s) to uninstall"
	});

	return parser;
}

var args = argumentParser().parseArgs();
main(args);
